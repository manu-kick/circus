cmake_minimum_required(VERSION 3.16)
project(circus_simulator)

# -------------------- Basics
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)
# Qt meta-build helpers:
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)
add_compile_definitions(PROJECT_ROOT="${CMAKE_SOURCE_DIR}")

include(FetchContent)

option(BUILD_PYTHON_BINDINGS "Build python bindings (nanobind)" ON)

# -------------------- Core dependencies
find_package(Eigen3 REQUIRED)
find_package(OpenGL REQUIRED)
find_package(Qt6 REQUIRED COMPONENTS Core Widgets OpenGLWidgets)


# Optional deps (linked only if found)
find_package(nlohmann_json QUIET)
find_package(CURL QUIET)

# -------------------- yaml-cpp (config -> module -> manual) [robust]
set(_YAML_HINT "/opt/homebrew/opt/yaml-cpp")
find_package(yaml-cpp CONFIG QUIET)
if(NOT (TARGET yaml-cpp::yaml-cpp OR TARGET yaml-cpp))
  find_package(yaml-cpp QUIET)
endif()
if(TARGET yaml-cpp::yaml-cpp OR TARGET yaml-cpp)
  if(TARGET yaml-cpp::yaml-cpp AND NOT TARGET yaml-cpp)
    add_library(yaml-cpp ALIAS yaml-cpp::yaml-cpp)
  elseif(TARGET yaml-cpp AND NOT TARGET yaml-cpp::yaml-cpp)
    add_library(yaml-cpp::yaml-cpp ALIAS yaml-cpp)
  endif()
else()
  find_path(YAMLCPP_INCLUDE_DIR yaml-cpp/yaml.h
    HINTS "${_YAML_HINT}/include" /opt/homebrew/include /usr/local/include)
  find_library(YAMLCPP_LIBRARY NAMES yaml-cpp
    HINTS "${_YAML_HINT}/lib" /opt/homebrew/lib /usr/local/lib)
  if(NOT YAMLCPP_LIBRARY OR NOT YAMLCPP_INCLUDE_DIR)
    message(FATAL_ERROR "yaml-cpp not found. Install via pixi/conda-forge or set YAMLCPP_LIBRARY and YAMLCPP_INCLUDE_DIR.")
  endif()
  add_library(yaml-cpp UNKNOWN IMPORTED GLOBAL)
  set_target_properties(yaml-cpp PROPERTIES IMPORTED_LOCATION "${YAMLCPP_LIBRARY}")
  target_include_directories(yaml-cpp INTERFACE "${YAMLCPP_INCLUDE_DIR}")
  add_library(yaml-cpp::yaml-cpp ALIAS yaml-cpp)
endif()

# -------------------- MuJoCo (package first; macOS framework fallback)
find_package(mujoco CONFIG QUIET)
if (TARGET mujoco::mujoco)
  message(STATUS "MuJoCo: using CMake package target mujoco::mujoco")
else()
  message(STATUS "MuJoCo: package not found, trying platform-specific fallback")
  if(APPLE)
    find_library(MUJOCO_FRAMEWORK
      NAMES mujoco
      PATHS /Library/Frameworks ~/Library/Frameworks /Applications/MuJoCo.app/Contents/Frameworks
      PATH_SUFFIXES mujoco.framework
    )
    if(NOT MUJOCO_FRAMEWORK)
      message(FATAL_ERROR "MuJoCo not found: neither mujoco CMake package nor system framework.\n"
                          "Install libmujoco via pixi (recommended) OR copy mujoco.framework to /Library/Frameworks.")
    endif()
    add_library(mujoco::mujoco INTERFACE IMPORTED)
    get_filename_component(_MJ_FW_DIR "${MUJOCO_FRAMEWORK}" DIRECTORY)
    target_link_options(mujoco::mujoco INTERFACE
      "-F${_MJ_FW_DIR}" "-framework" "mujoco" "-Wl,-rpath,${_MJ_FW_DIR}"
    )
    if(EXISTS "${MUJOCO_FRAMEWORK}/Headers/mujoco/mujoco.h")
      target_include_directories(mujoco::mujoco INTERFACE "${MUJOCO_FRAMEWORK}/Headers")
    endif()
  elseif(WIN32)
    message(FATAL_ERROR "Windows fallback for MuJoCo not configured. Please install libmujoco via pixi.")
  else()
    message(FATAL_ERROR "Linux fallback for MuJoCo not configured. Please install libmujoco via pixi.")
  endif()
endif()

# -------------------- pugixml (package first; auto-fetch fallback)
set(_PUGI_TGT "")
find_package(pugixml CONFIG QUIET)
if (TARGET pugixml::pugixml)
  set(_PUGI_TGT pugixml::pugixml)
  message(STATUS "pugixml: using package target pugixml::pugixml")
else()
  message(STATUS "pugixml: package not found, fetching from upstream")
  FetchContent_Declare(
    pugixml
    GIT_REPOSITORY https://github.com/zeux/pugixml.git
    GIT_TAG v1.14
  )
  FetchContent_MakeAvailable(pugixml)
  if(TARGET pugixml)
    set(_PUGI_TGT pugixml)
  elseif(TARGET pugixml-static)
    set(_PUGI_TGT pugixml-static)
  else()
    message(FATAL_ERROR "pugixml target not found after FetchContent; expected 'pugixml' or 'pugixml-static'.")
  endif()
endif()

# -------------------- Project includes
include_directories(${CMAKE_SOURCE_DIR}/Include)

# -------------------- Collect sources and split into: core, main, bindings
set(_src_dir "")
if(EXISTS "${CMAKE_SOURCE_DIR}/Src")
  set(_src_dir "${CMAKE_SOURCE_DIR}/Src")
elseif(EXISTS "${CMAKE_SOURCE_DIR}/src")
  set(_src_dir "${CMAKE_SOURCE_DIR}/src")
else()
  message(FATAL_ERROR "No 'Src' or 'src' directory found.")
endif()

# C/C++ sources
file(GLOB_RECURSE ALL_CPP CONFIGURE_DEPENDS
  "${_src_dir}/*.[cC]pp" "${_src_dir}/*.[cC]xx" "${_src_dir}/*.[cC]"
)

# Headers (include them so AUTOMOC sees Q_OBJECT)
file(GLOB_RECURSE ALL_HEADERS CONFIGURE_DEPENDS
  "${_src_dir}/*.[hH]" "${_src_dir}/*.[hH]pp"
  "${CMAKE_SOURCE_DIR}/Include/*.[hH]" "${CMAKE_SOURCE_DIR}/Include/*.[hH]pp"
)

# Optional Qt UI and resource files (AUTOUIC/AUTORCC will process these)
file(GLOB_RECURSE ALL_UIS  CONFIGURE_DEPENDS "${_src_dir}/*.ui")
file(GLOB_RECURSE ALL_QRCS CONFIGURE_DEPENDS "${_src_dir}/*.qrc")

# Identify entry points we don't want in the core lib
set(MAIN_SRC "")
if(EXISTS "${_src_dir}/main.cpp")
  set(MAIN_SRC "${_src_dir}/main.cpp")
endif()

set(BINDINGS_SRC "")
if(EXISTS "${_src_dir}/Bindings.cpp")
  set(BINDINGS_SRC "${_src_dir}/Bindings.cpp")
endif()

# Core = everything minus main & bindings (+ headers/ui/qrc so automoc/uic/rcc run)
set(CORE_SOURCES ${ALL_CPP} ${ALL_HEADERS} ${ALL_UIS} ${ALL_QRCS})
if(MAIN_SRC)
  list(REMOVE_ITEM CORE_SOURCES "${MAIN_SRC}")
endif()
if(BINDINGS_SRC)
  list(REMOVE_ITEM CORE_SOURCES "${BINDINGS_SRC}")
endif()


# -------------------- Libraries to link everywhere
set(_EXTRA_LIBS
  mujoco::mujoco
  yaml-cpp::yaml-cpp
  Eigen3::Eigen
  Qt6::Core
  Qt6::Widgets
  Qt6::OpenGLWidgets
  OpenGL::GL
  ${_PUGI_TGT}
)
if(TARGET nlohmann_json::nlohmann_json)
  list(APPEND _EXTRA_LIBS nlohmann_json::nlohmann_json)
endif()
if(TARGET CURL::libcurl)
  list(APPEND _EXTRA_LIBS CURL::libcurl)
endif()

# --- Build core library (ensure AUTOMOC is on for the target)
add_library(circus_core STATIC ${CORE_SOURCES})
set_target_properties(circus_core PROPERTIES AUTOMOC ON AUTOUIC ON AUTORCC ON)
target_include_directories(circus_core PUBLIC "${CMAKE_SOURCE_DIR}/Include" "${_src_dir}")
target_link_libraries(circus_core PUBLIC ${_EXTRA_LIBS})

# -------------------- Build the app
if(MAIN_SRC)
  add_executable(main ${MAIN_SRC})
  target_link_libraries(main PRIVATE circus_core)
else()
  message(WARNING "No main.cpp found in ${_src_dir}; skipping executable 'main'.")
endif()

# -------------------- Python bindings via nanobind
if(BUILD_PYTHON_BINDINGS AND BINDINGS_SRC)
  # Python (Interpreter + Development.Module)
  set(_PY_COMPS Interpreter Development.Module)
  find_package(Python QUIET COMPONENTS ${_PY_COMPS})
  if(NOT Python_FOUND)
    find_package(Python3 REQUIRED COMPONENTS ${_PY_COMPS})
    set(Python_EXECUTABLE ${Python3_EXECUTABLE})
    set(Python_SITEARCH  ${Python3_SITEARCH})
  endif()

  # Locate nanobind's CMake package via the Python module
  execute_process(
    COMMAND "${Python_EXECUTABLE}" -m nanobind --cmake_dir
    OUTPUT_STRIP_TRAILING_WHITESPACE OUTPUT_VARIABLE _NB_CMAKE_DIR
    RESULT_VARIABLE _NB_RET
  )
  if(NOT _NB_RET EQUAL 0)
    message(FATAL_ERROR "Failed to locate nanobind via 'python -m nanobind --cmake_dir'. "
                        "Is 'nanobind' installed in this pixi env?")
  endif()
  set(nanobind_DIR "${_NB_CMAKE_DIR}")
  find_package(nanobind CONFIG REQUIRED)

  # Determine Python's site-packages (platlib)
  if(NOT Python_SITEARCH)
    execute_process(
      COMMAND "${Python_EXECUTABLE}" -c "import sysconfig; print(sysconfig.get_path('platlib'))"
      OUTPUT_STRIP_TRAILING_WHITESPACE OUTPUT_VARIABLE Python_SITEARCH
    )
  endif()

  # Auto-detect module name from NB_MODULE(...) in Bindings.cpp (e.g., 'circuspy')
  file(READ "${BINDINGS_SRC}" _NB_SRC)
  string(REGEX MATCH "NB_MODULE\\s*\\(([A-Za-z_][A-Za-z0-9_]*)" _m "${_NB_SRC}")
  if(NOT _m)
    message(FATAL_ERROR "Could not find NB_MODULE(...) in ${BINDINGS_SRC}")
  endif()
  set(PY_MODULE_NAME "${CMAKE_MATCH_1}")
  message(STATUS "nanobind: detected module name '${PY_MODULE_NAME}' from ${BINDINGS_SRC}")

  # Build the nanobind module
  nanobind_add_module(${PY_MODULE_NAME} ${BINDINGS_SRC})
  target_link_libraries(${PY_MODULE_NAME} PRIVATE circus_core)

  # Install Python module into the environment's site-packages
  install(TARGETS ${PY_MODULE_NAME}
    LIBRARY DESTINATION "${Python_SITEARCH}"
  )
endif()

# -------------------- Install the app (so 'ninja install' exists for pixi)
include(GNUInstallDirs)
if(TARGET main)
  install(TARGETS main
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    BUNDLE  DESTINATION ${CMAKE_INSTALL_BINDIR}
  )
endif()
